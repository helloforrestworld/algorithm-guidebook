算法是指用来操作数据、解决程序问题的一组方法。对于同一个问题，使用不同的算法，也许最终的结果是一样的，但在过程中消耗的资源和时间却有很大的区别。那么如何去衡量不同算法之间的优劣呢？

主要从【时间维度】和【空间维度】去考量。

- 时间维度：是指执行当前算法所消耗的时间，我们通常用「时间复杂度」来描述。
- 空间维度：是指执行当前算法需要占用多少内存空间，我们通常用「空间复杂度」来描述。

## 时间复杂度

通用的方法：「 大 O 符号表示法 」，即 T(n) = O(f(n))

大 O 符号表示法并不是用于来真实代表算法的执行时间的，它是用来表示代码执行时间的增长变化趋势的。

例如下面的代码，不管 n 是多少，代码都只执行一次。我们称为 **常数阶复杂度，O(1)**

```js
let n = 1000;
console.log(`exec code to add n * 2 = ${n * 2}`);
```

即使代码再增加几行，复杂度也是常数级 O(1)， 虽然严格上它是 O(3)，但是这种常数在算法时间复杂度计量中可以忽略。

```js
let n = 1000;
console.log(`exec code to add n * 2 = ${n * 2}`);
console.log(`exec code to add n + 2 = ${n + 2}`);
console.log(`exec code to add n - 2 = ${n - 2}`);
```

再看下面代码 ，普通一个循环语句，这段代码，for 循环里面的代码会执行 n 遍，因此它消耗的时间是随着 n 的变化而变化的，因此这类代码都可以用 O(n)来表示它的时间复杂度。

```js
for (let i = 0; i < n; i++) {
  console.log(i);
}
```

常见的时间复杂度量级有：

- 常数阶 O(1)
- 对数阶 O(logN)
- 线性阶 O(n)
- 线性对数阶 O(nlogN)
- 平方阶 O(n²)
- 立方阶 O(n³)
- K 次方阶 O(n^k)
- 指数阶(2^n)

上面从上至下依次的时间复杂度越来越大，执行的效率越来越低。

### 常数阶 O(1)

执行次数与 N 无关， 执行  次数都为常数级别。

```js
let n = 1000;
n++;
console.log(n);
```

### 对数阶 O(logN)

先看代码

```js
let i = 1;
while (i < n) {
  i = i * 2;
}
```

每次进入循环 i \* 2，当循环 x 次时，i 大于等于 n 时，也就是 2 的 x 次方等于 n 时，那么 x = log2^n，常数底数 2 可以忽略，因此这个代码的时间复杂度为：O(logn)

### 线性阶 O(n)

for 循环里面的代码会执行 n 遍，因此它消耗的时间是随着 n 的变化而变化的，因此这类代码都可以用 O(n)来表示它的时间复杂度。

```js
for (let i = 0; i < n; i++) {
  console.log(i);
}
```

### 线性对数阶 O(nlogN)

线性对数阶 O(nlogN) 其实非常容易理解，将时间复杂度为 O(logn)的代码循环 N 遍的话，那么它的时间复杂度就是 n \* O(logN)，也就是了 O(nlogN)。

```js
for (let j = 1; j < n; j++) {
  let i = 1;
  while (i < n) {
    i = i * 2;
  }
}
```

### 平方阶 O(n²)

平方阶 O(n²) 就更容易理解了，如果把 O(n) 的代码再嵌套循环一遍，它的时间复杂度就是 O(n²) 了。

```js
for (x = 1; i <= n; x++) {
  for (i = 1; i <= n; i++) {
    j = i;
    j++;
  }
}
```

这段代码其实就是嵌套了 2 层 n 循环，它的时间复杂度就是 O(n\*n)，即 O(n²)
如果将其中一层循环的 n 改成 m，即：

```js
for (x = 1; i <= m; x++) {
  for (i = 1; i <= n; i++) {
    j = i;
    j++;
  }
}
```

那它的时间复杂度就变成了 O(m\*n)

### 立方阶 O(n³)、K 次方阶 O(n^k)

参考上面的 O(n²) 去理解就好了，O(n³)相当于三层 n 循环，其它的类似。

### 指数阶(2^n)

## 空间复杂度

空间复杂度和时间复杂度的情况其实类似，但是它更加的简单。用最简单的方式来分析即可。主要有两个原则：

- 如果你的代码中开了数组，那么数组的长度基本上就是你的空间复杂度。比如你开了一个一维的数组，那么你的空间复杂度就是 O(n)，如果开了一个二维的数组，数组长度是 n^2，那么空间复杂度基本上就是 n^2
- 如果是有递归的话，那么它递归最深的深度，就是你空间复杂度的最大值。如果你的程序里边递归中又开了数组，那么空间复杂度就是两者的最大值
